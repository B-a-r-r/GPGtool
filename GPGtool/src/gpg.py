from dataclasses import dataclass
from typing import Mapping
from gnupg import GPG
from os import path

@dataclass
class Key_inputs(Mapping):
    
    name_email: str
    passphrase: str
    name_real: str
    key_type: str
    key_length: int
    name_comment: str
    key_usage: str
    
    def __init__(self, name_email:str,
                 key_usage:str=None,
                 passphrase:str=None, 
                 name_real:str='Anonymous',
                 key_type:str='RSA', 
                 key_length:int=2048
                 )->None:
        self.name_email = name_email
        self.passphrase = passphrase
        self.name_real = name_real
        self.key_type = key_type
        self.key_length = key_length   
        self.name_comment = "Generated by GPGtool." 
        self.key_usage = key_usage
        
        self._verify_inputs()
    
    def __init__(self)->None:
        tmp = str(input("[GPGtool][!] Enter your key purpose (optional): "))
        self.key_usage = tmp if tmp else 'Undef'
        self.name_email = str(input("[GPGtool][!] Enter your email: "))
        i=0
        while (self.name_email == ""):
            if (i>5):
                raise SystemExit("[GPGtool][!] You have reached the maximum number of attempts.")
            self.name_email = str(input("[GPGtool][!] Enter your email: "))
            i+=1
        
        self.passphrase = str(input("[GPGtool][!] Enter a passphrase to protect your new key: "))
        i=0
        while (self.passphrase == ""):
            if (i>5):
                raise SystemExit("[GPGtool][!] You have reached the maximum number of attempts.")
            self.passphrase = str(input("[GPGtool][!] Enter a passphrase: "))
            i+=1
        
        tmp = str(input("[GPGtool][!] Enter your key type (default is RSA): "))
        self.key_type = tmp if tmp else 'RSA'
        tmp = str(input("[GPGtool][!] Enter your key length (default is 2048): "))
        self.key_length = int(tmp) if tmp else 2048
        tmp = str(input("[GPGtool][!] Would you give your key name ? (optional): "))
        self.name_real = tmp if tmp else 'Anonymous'
        self.name_comment = "Generated by GPGtool."
        
        self._verify_inputs()
    
    def __getitem__(self, key: str) -> str: return self.__getattribute__(key)
    def __iter__(self): return iter(self.__dict__()) 
    def __len__(self): return len(self.__dict__())
    
    def __dict__(self) -> dict:
        return {
            'name_real':self.name_real,
            'name_email':self.name_email,
            'passphrase':self.passphrase,
            'key_length':self.key_length,
            'key_type':self.key_type,
            'key_usage':self.key_usage,
            'name_comment':self.name_comment
        }
    
    def __eq__(self, other: object) -> bool:
        """
        Compare the current object attributes value with a other object.
        Args:
            other (object): The object to compare with.
        Returns:
            bool: True if the objects are equal, False otherwise.
        """
        if (isinstance(other, Key_inputs)):
            return (self.name_email == other.name_email and
                    self.passphrase == other.passphrase and
                    self.name_real == other.name_real and
                    self.key_type == other.key_type and
                    self.key_length == other.key_length and
                    self.name_comment == other.name_comment)
        else:
            return False
    
    def _verify_inputs(self)->None:
        """
        Verify the key inputs. If the inputs are invalid, report an error.
        """
        if (self.name_email.__contains__("@") and self.name_email.__contains__(".")):
            tmp = self.name_email.split("@")
            if (len(tmp[0]) >= 1 and len(tmp[1]) >= 3):
                tmp = tmp[1].split(".")
                if (not(len(tmp[0]) >= 1 and len(tmp[1]) >= 1)):
                    self._handle_error(1)
            else:
                self._handle_error(1)
        else:
            self._handle_error(1)

        if (self.key_length < 1024 or self.key_length > 4096):
            self._handle_error(2)
        
        if (self.key_type != 'RSA' and self.key_type != 'DSA'):
            self._handle_error(3)
    
    def __hash__(self) -> int:
        return hash((self.name_email, self.passphrase, self.name_real, self.key_type, self.key_length, self.name_comment))
    
    def __repr__(self) -> str:
        return f"\n[GPGtool] Key inputs (hash : '{self.__hash__()})':\
        \n\t- Real name: {self.name_real}\
        \n\t- Usage: {self.key_usage}\
        \n\t- Email: {self.name_email}\
        \n\t- Passphrase: {self.passphrase}\
        \n\t- Key type: {self.key_type}\
        \n\t- Key length: {self.key_length}\
        \n"
    
    def _handle_error(self, error_code:int)->str:
        """
        Raise an error according to a error number reported, then crash the app.
        Args:
            error (int): the number of the reported error.
        """
        match error_code:
            case 1:
                raise SystemExit("[GPGtool] Crash report : invalid key inputs -> email address; in gpg.py.")
            case 2:
                raise SystemExit("[GPGtool] Crash report : invalid key inputs -> invalid key length; in gpg.py.")
            case 3:
                raise SystemExit("[GPGtool] Crash report : invalid key inputs -> unsupported key type; in gpg.py.")
            case _:
                raise SystemExit("[GPGtool] Crash report : invalid key inputs -> unknown error reported; in gpg.py.")


class GPG_engine():
    
    gpg: GPG
    key_inputs: Key_inputs
    
    def __init__(self)->None:
        self.gpg = GPG(gnupghome = path.expanduser('~/.gnupg'))
        self.gpg.encoding = 'utf-8'

    def _set_key_input(self, key_inputs:Key_inputs)->str:
        """
        Set the key input for the ondoing key generation.
        Args:
            key_inputs (Key_inputs): A dataclass containing the key inputs.
        """
        return self.gpg.gen_key_input(**key_inputs)
        
    
    def keygen(self, key_inputs:Key_inputs)->None:
        """
        Generate a key pair according to user's inputs.
        Args:
            key_inputs (Key_inputs): A dataclass containing the key inputs.
        """
        
        print(self.gpg.list_keys(secret=True).__repr__())
        debug = self.gpg.gen_key(self._set_key_input(key_inputs))
        print(self.gpg.list_keys(secret=True).__repr__())
        print(debug)
    
    def select_key(self, key_id:str)->str:
        """
        Select a key from the keyring.
        Args:
            key_id (str): The key ID.
        Returns:
            str: The key ID.
        """
        pass
    
    def delete_key(self, key_id:str)->str:
        """
        Delete a key from the keyring.
        Args:
            key_id (str): The key ID.
        Returns:
            str: The key ID.
        """
        pass
    
    def encrypt(self, message:str, public_key:str)->str:
        """
        Encrypt a string with a key.
        Args:
            message (str): The message to encrypt.
            public_key (str): The encryption key.
        Returns:
            str: The encrypted message.
        """
        self.gpg.encrypt(data=message, recipients=public_key)
    
    def decrypt(self, message:str, passphrase:str, private_key:str)->str:
        """
        Decrypt a string with a key.
        Args:
            message (str): The message to decrypt.
            private_key (str): The decryption key.
        Returns:
            str: The decrypted message.
        """
        self.gpg.decrypt(message, passphrase=private_key)
    
    def export_public_key(self, key_id:str, output:str=None)->str:
        """
        Export a public key.
        Args:
            key_id (str): The key ID.
        Returns:
            str: The public key.
        """
        return self.gpg.export_keys(key_id)

    def export_private_key(self, key_id:str, output:str=None)->str:
        """
        Export a private key.
        Args:
            key_id (str): The key ID.
        Returns:
            str: The private key.
        """
        if (self.key_inputs.passphrase):
            return self.gpg.export_keys(key_id, True, passphrase=self.key_inputs.passphrase)
        else:
            return self.gpg.export_keys(key_id, True)
    
    def import_public_key(self, key:str):
        """
        Import a public key.
        Args:
            key (str): The public key.
        """
        self.gpg.import_keys(key)
    
    def import_private_key(self, key:str, passphrase:str=None)->None:
        """
        Import a private key.
        Args:
            key (str): The private key.
        """
        self.gpg.import_keys(key, passphrase=passphrase) if passphrase else self.gpg.import_keys(key)
    
    def import_key_from_file(self, file:str)->None:
        """
        Import a key from a file.
        Args:
            file (str): The file containing the key.
        """
        self.gpg.import_keys_file(file)
    
    def list_keys(self, mode:str="api", secret=False)->any:
        """
        List all the keys in the keyring in the console or return the listing directly.
        Args:
            mode (str, optional): "cli": print int he console ; "api": return the listing. Defaults to "api".
            secret (bool, optional): True if the secret keys are listed, False otherwise. Defaults to False.
        Returns:
            any: None or str.
        """
        match mode:
            case "api":
                return self.gpg.list_keys(secret=secret).__repr__()
            case "cli":
                prop = ""
                for char in self.gpg.list_keys(secret=secret).__repr__():
                    if (char == ',') :
                        print(prop)
                        prop = "" 
                    elif (char == '}'):
                        print('\n')
                    else :
                        prop += char
            case _:
                self._handle_error(3)
    
    def _handle_error(self, error_code:int)->str:
        """
        Create an error according to a error number reported, then crash the app.
        Args:
            error (int): the number of the reported error.
        """
        match error_code:
            case 0:
                raise SystemExit("[GPGtool] The application has been shot down; from gpg.py.")
            case 3:
                raise SystemExit("[GPGtool] Crash report : unknown listing mode selected; in gpg.py.")
            case _:
                raise SystemExit("[GPGtool] Crash report : unknown error reported; in gpg.py.")
    

if __name__ == '__main__':
    gpg = GPG_engine()
    key_inputs = Key_inputs()
    gpg.keygen(key_inputs)
    gpg.list_keys(mode="cli",secret=True)
    
    