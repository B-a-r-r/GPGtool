from dataclasses import dataclass
from typing import Mapping
from gnupg import GPG
from os import path

@dataclass
class Key_inputs():
    
    (EXPECTED_ARGS) = ('name_email', 
                       'passphrase', 
                       'name_real', 
                       'key_type', 
                       'key_length',
                       'expire_date',
                       'name_comment',
                       'no_protection'                       
    )
    args: Mapping[str, str]
    
    def __init__(self, mode:str="api", **kwargs: Mapping[str, str])->None:
        """
        Initialize the key inputs; if the mode is 'cli', the user will be asked to enter the inputs.
        Args:
            **kwargs (Mapping[str, str]): The key inputs -> name_email, passphrase, name_real, key_type, key_length, key_usage, mode.
        """
        if (mode.title() == "CLI"):
            
            self.args['name_email'] = str(input("[GPGtool][!] Enter your email: "))
            i=0
            while (self.args['name_email'] == ""):
                if (i>5):
                    self._handle_error(4)
                self.args['name_email'] = str(input("[GPGtool][!] Enter your email: "))
                i+=1
            
            while (not self.args.__contains__('passphrase')
                   or not self.args['no_protection']):
                tmp = str(input("[GPGtool][!] Enter a passphrase to protect your new key: "))
                if (tmp == ""):
                    tmp = str(input("[GPGtool][!] Are you sure you don't want to protect your key with a passphrase ? (y/n) "))
                    if (tmp == "y" or tmp == "Y" or tmp == ""):
                        self.args['no_protection'] = True
                    else:
                        continue
            
            tmp = str(input("[GPGtool][!] Enter your key type (default is RSA): "))
            self.args['key_type'] = tmp if tmp else 'RSA'
            
            tmp = str(input("[GPGtool][!] Enter your key length (default is 2048): "))
            self.args['key_length'] = int(tmp) if tmp else 2048
            
            tmp = str(input("[GPGtool][!] Would you give your key a name ? (optional): "))
            self.args['name_real'] = tmp if tmp else 'Anonymous'
            
            tmp = str(input("[GPGtool][!] Would you set an expire date for your key ? (optional): "))
            self.args['expire_date'] = tmp if tmp else '0'
    
            self.args['name_comment'] = "Generated by GPGtool."
        
        elif (mode.title() == "API"):
            self.args = kwargs
            if (not self.args.__contains__('passphrase')):
                self.args['no_protection'] = True
            self.args['name_comment'] = "Generated by GPGtool."
        
        else:
            self._handle_error(7, info=mode)
            
        self._verify_inputs()
    
    def __dict__(self) -> dict:
        return self.args
    
    def __eq__(self, other: object) -> bool:
        """
        Compare the current object attributes value with a other object.
        Args:
            other (object): The object to compare with.
        Returns:
            bool: True if the objects are equal, False otherwise.
        """
        if (isinstance(other, Key_inputs)):
            return (self.args['name_email'] == other.args['name_email'] and
                    self.args['passphrase'] == other.args['passphrase'] and
                    self.args['name_real'] == other.args['name_real'] and
                    self.args['key_type'] == other.args['key_type'] and
                    self.args['key_length'] == other.args['key_length'] and 
                    self.args['name_comment'] == other.args['name_comment'])
        else:
            return False
    
    def _verify_inputs(self)->None:
        """
        Verify the key inputs. If the inputs are invalid, report an error.
        """
        occured_errors = []
        try:
            if (self.args['name_email'].__contains__("@")):
                tmp = self.args['name_email'].split("@")
                if (len(tmp[0]) >= 1 and len(tmp[1]) >= 3):
                    if (tmp[1].__contains__(".")):
                        tmp = tmp[1].split(".")
                        if (len(tmp[0]) < 1 or len(tmp[len(tmp)-1]) < 1):
                            self._handle_error(1)
                    else:
                        self._handle_error(1)
                else:
                    self._handle_error(1)
            else:
                self._handle_error(1)
  
        except KeyError as err:
            occured_errors.append(err)
            
        try: 
            if (self.args['key_length'] < 1024 or self.args['key_length'] > 4096):
                self._handle_error(2)
                
        except KeyError as err:
            occured_errors.append(err)
        
        try:   
            if (self.args['key_type'] != 'RSA' 
                and self.args['key_type'] != 'DSA'
                and self.args['key_type'] != 'ELG-E'):
                self._handle_error(3)
                
        except KeyError as err:
            occured_errors.append(err)
        
        if (self.args.__contains__('expire_date')
            and self.args['expire_date'] != '0'
            and self.args['expire_date'] != '%m'
            and self.args['expire_date'] != '%d'
            and self.args['expire_date'] != '%w'
            and self.args['expire_date'] != '%y'
            and self.args['expire_date'] != 'seconds=%'
            ):
            if (self.args['expire_date'] == '%-%-%'):
                tmp = self.args['expire_date'].split("-")
                if (len(tmp[0]) == 4):
                    if (len(tmp[1]) == 2):
                        if (len(tmp[2]) == 2):
                            pass
                        else:
                            self._handle_error(5)
                    else:
                        self._handle_error(5)
                else:
                    self._handle_error(5)
            else:
                self._handle_error(5)
        
        if (self.args.__contains__('no_protection') 
            and self.args.__contains__('passphrase')
            and self.args['no_protection']):
            self._handle_error(6)
        
        self._handle_error(0, info=occured_errors) if len(occured_errors)>0 else None
        
        tmp_to_delete = []
        for key in self.args:
            if (not self.EXPECTED_ARGS.__contains__(key)):
                tmp_to_delete.append(key)
        for key in tmp_to_delete:
            del self.args[key]     
    
    def __hash__(self) -> int:
        return hash((self.args['name_email'], self.args['passphrase'], self.args['name_real'], self.args['key_type'], self.args['key_length'], self.args['name_comment']))
    
    def __repr__(self) -> str:
        return f"\n[GPGtool] Key inputs (hash : '{self.__hash__()})':\
        \n\t- Real name: {self.args['name_real'] if self.args.__contains__('name_real') else ""}\
        \n\t- Email: {self.args['name_email'] if self.args.__contains__('name_email') else ""}\
        \n\t- Passphrase: {self.args['passphrase'] if self.args.__contains__('passphrase') else ""}\
        \n\t- Key type: {self.args['key_type'] if self.args.__contains__('key_type') else "RSA"}\
        \n\t- Key length: {self.args['key_length'] if self.args.__contains__('key_length') else "2048"}\
        \n\t- Expire date: {self.args['expire_date'] if self.args.__contains__('expire_date') else "0"}\
        \n\t- No_protection: {self.args['no_protection'] if self.args.__contains__('no_protection') else "False"}\
        \n\t- Comment: {self.args['name_comment'] if self.args.__contains__('name_comment') else ""}"
    
    def _handle_error(self, error_code:int, info:any="")->str:
        """
        Raise an error according to a error number reported, then crash the app.
        Args:
            error (int): the number of the reported error.
        """
        match error_code:
            case 0:
                raise SystemExit("[GPGtool] Crash report : invalid key inputs -> one or more required arguments may not have been entered; from gpg.py." \
                                + "\n           Missing argument(s) -> " + info.__repr__())
            case 1:
                raise SystemExit("[GPGtool] Crash report : invalid key inputs -> email address; in gpg.py.")
            case 2:
                raise SystemExit("[GPGtool] Crash report : invalid key inputs -> invalid key length; in gpg.py.")
            case 3:
                raise SystemExit("[GPGtool] Crash report : invalid key inputs -> unsupported key type; in gpg.py.")
            case 4:
                raise SystemExit("[GPGtool] Crash report : maximum number of attempts reached for mandatory parameter selection.; in gpg.py.")
            case 5:
                raise SystemExit("[GPGtool] Crash report : invalid key inputs -> wrong syntax for expire date; in gpg.py.")
            case 6:
                raise SystemExit("[GPGtool] Crash report : invalid key inputs -> conflicting arguments passphrase and no_protection; in gpg.py.")
            case 7 :
                raise SystemExit(f"[GPGtool] Crash report : unknown key inputs entering mode {info} selected; in gpg.py.")
            case _:
                raise SystemExit("[GPGtool] Crash report : unknown key inputs error reported; in gpg.py.")


class GPG_engine():
    
    gpg: GPG
    key_inputs: Key_inputs
    
    def __init__(self)->None:
        self.gpg = GPG(gnupghome = path.expanduser('~/.gnupg'))
        self.gpg.encoding = 'utf-8'

    def _set_key_input(self, key_inputs:Key_inputs)->str:
        """
        Set the key input for the ondoing key generation.
        Args:
            key_inputs (Key_inputs): A dataclass containing the key inputs.
        """
        return self.gpg.gen_key_input(**key_inputs.__dict__())
    
    def keygen(self, key_inputs:Key_inputs)->None:
        """
        Generate a key pair according to user's inputs.
        Args:
            key_inputs (Key_inputs): A dataclass containing the key inputs.
        """
        result = self.gpg.gen_key(self._set_key_input(key_inputs))
        print(result.__repr__())  
    
    def select_key(self, key_id:str)->str:
        """
        Select a key from the keyring.
        Args:
            key_id (str): The key ID.
        Returns:
            str: The key ID.
        """
        pass
    
    def delete_key(self, key_id:str)->str:
        """
        Delete a key from the keyring.
        Args:
            key_id (str): The key ID.
        Returns:
            str: The key ID.
        """
        pass
    
    def encrypt(self, message:str, public_key:str)->str:
        """
        Encrypt a string with a key.
        Args:
            message (str): The message to encrypt.
            public_key (str): The encryption key.
        Returns:
            str: The encrypted message.
        """
        self.gpg.encrypt(data=message, recipients=public_key)
    
    def decrypt(self, message:str, passphrase:str, private_key:str)->str:
        """
        Decrypt a string with a key.
        Args:
            message (str): The message to decrypt.
            private_key (str): The decryption key.
        Returns:
            str: The decrypted message.
        """
        self.gpg.decrypt(message, passphrase=private_key)
    
    def export_public_key(self, key_id:str, output:str=None)->str:
        """
        Export a public key.
        Args:
            key_id (str): The key ID.
        Returns:
            str: The public key.
        """
        return self.gpg.export_keys(key_id)

    def export_private_key(self, key_id:str, output:str=None)->str:
        """
        Export a private key.
        Args:
            key_id (str): The key ID.
        Returns:
            str: The private key.
        """
        if (self.key_inputs.args['passphrase']):
            return self.gpg.export_keys(key_id, True, passphrase=self.key_inputs.args['passphrase'])
        else:
            return self.gpg.export_keys(key_id, True)
    
    def import_public_key(self, key:str):
        """
        Import a public key.
        Args:
            key (str): The public key.
        """
        self.gpg.import_keys(key)
    
    def import_private_key(self, key:str, passphrase:str=None)->None:
        """
        Import a private key.
        Args:
            key (str): The private key.
        """
        self.gpg.import_keys(key, passphrase=passphrase) if passphrase else self.gpg.import_keys(key)
    
    def import_key_from_file(self, file:str)->None:
        """
        Import a key from a file.
        Args:
            file (str): The file containing the key.
        """
        self.gpg.import_keys_file(file)
    
    def list_keys(self, mode:str="api", secret=False)->any:
        """
        List all the keys in the keyring in the console or return the listing directly.
        Args:
            mode (str, optional): "cli": print int he console ; "api": return the listing. Defaults to "api".
            secret (bool, optional): True if the secret keys are listed, False otherwise. Defaults to False.
        Returns:
            any: None or str.
        """
        match mode.title():
            case "API":
                return self.gpg.list_keys(secret=secret).__repr__()
            case "CLI":
                prop = ""
                for char in self.gpg.list_keys(secret=secret).__repr__():
                    if (char == ',') :
                        print(prop)
                        prop = "" 
                    elif (char == '}'):
                        print('\n')
                    else :
                        prop += char
            case _:
                self._handle_error(3)
    
    def _handle_error(self, error_code:int)->str:
        """
        Create an error according to a error number reported, then crash the app.
        Args:
            error (int): the number of the reported error.
        """
        match error_code:
            case 0:
                raise SystemExit("[GPGtool] The application has been shot down; from gpg.py.")
            case 3:
                raise SystemExit("[GPGtool] Crash report : unknown listing mode selected; in gpg.py.")
            case _:
                raise SystemExit("[GPGtool] Crash report : unknown error reported; in gpg.py.")
    

if __name__ == '__main__':
    pass
    